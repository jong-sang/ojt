# Javascript

### 개요

자바스크립트(Javascript)는 객체 기반의 스크립트 언어입니다.  
 HTML로 작성된 웹 페이지를 자바스크립트를 이용해 동적으로 사용자와 상호작용 할 수 있습니다.  
 주로 웹 브라우저에서 사용되나, Node.js와 같은 프레임워크를 사용하면 서버측 프로그래밍에서도 사용할 수 있습니다.

#

### 특징

- 자바스크립트는 객체기반의 스크립트 언어입니다.
- 자바스크립트는 동적이며, 타입을 명시할 필요가 없는 인터프리터 언어입니다.
- 객체 지향형 프로그래밍과 함수형 프로그래밍을 모두 표현할 수 있습니다.

#

### 변수

- 변수는 값을 할당하고 그 값을 참조하기 위해 사용합니다.
- 변수는 위치(주소)를 기억하는 저장소이다. 위치란 메모리상의 주소(address)를 의미합니다.
- 변수란 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자라고 할 수 있습니다.

#

### 값

| 용어             | 의미                                                                        |
| ---------------- | --------------------------------------------------------------------------- |
| 데이터 타입      | 프로그래밍 언어에서 사용할 수 있는 값의 종류                                |
| 변수             | 값이 저장된 메모리 공간의 주소를 가리키는 식별자                            |
| 리터럴 (literal) | 소스코드 안에서 직접 만들어낸 상수 값 자체를 말하며 값을 구성하는 최소 단위 |

#

> 리터럴 표기법

```javascript
// 숫자 리터럴
1004

// 문자열 리터럴
"Hello"

// 불리언 리터럴
true
false

// null 리터럴
null

// undefined 리터럴
undefined

// 객체 리터럴
{ name: "Kim", age: 15 }

// 함수 리터럴
function() {}
```

#

> 자바스크립트의 모든 값은 데이터 타입을 갖는다

- 원시타입

  - number
  - string
  - boolean
  - null
  - undefined
  - symbol (ECMAScript 6)

- 객체타입
  - object

> 자바스크립트는 C 나 Java 와는 다르게 선언할 때 데이터 타입을 미리 지정하지 않는다.  
> 변수에 할당된 값의 타입에 의해 동적으로 변수의 타입이 결정된다.

#

### 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만듭니다. 이때 연산의 대상을 피연산자라고 합니다.

- 이상 산술 연산자

| 연산자 | 의미   |
| ------ | ------ |
| +      | 덧셈   |
| -      | 뺄셈   |
| \*     | 곱셈   |
| /      | 나눗셈 |
| %      | 나머지 |

#

- 단항 산술 연산자

| 연산자 | 의미                                                 |
| ------ | ---------------------------------------------------- |
| ++     | 증가                                                 |
| --     | 감소                                                 |
| +      | 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. |
| -      | 양수를 음수로 음수를 양수로 반전한 값을 반환한다.    |

#

- 할당 연산자

| 연산자 | 예시    | 동일 표현  |
| ------ | ------- | ---------- |
| =      | x = y   | x = y      |
| +=     | x += y  | x = x + y  |
| -=     | x -= y  | x = x - y  |
| \*=    | x \*= y | x = x \* y |
| /=     | x /= y  | x = x / y  |
| %=     | x %= y  | x = x % y  |

#

- 비교 연산자

| 연산자 | 의미        | 설명                         |
| ------ | ----------- | ---------------------------- |
| ==     | 동등 비교   | 비교하는 두 값이 같음        |
| ===    | 일치 비교   | 비교하는 두 값과 타입이 같음 |
| !=     | 부등 비교   | 비교하는 두 값이 다름        |
| !==    | 불일치 비교 | 비교하는 두 값과 타입이 다름 |
| >      | x > y       | x가 y보다 크다               |
| >=     | x >= y      | x가 y보다 크거나 같다        |

#

- 삼항 조건 연산자

> 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값

```javascript
x > y ? "Hello" : "Bye";
// x가 y보다 크다면 "Hello" 반환
// x가 y보다 작다면 "Bye" 반환
```

#

- 논리 연산자

| 연산자 | 의미        |
| ------ | ----------- |
| ll     | 논리합(OR)  |
| &&     | 논리곱(AND) |
| !      | 부정(NOT)   |

#

### 타입 변환

자바스크립트의 모든 값에는 타입이 있습니다. 값의 타입은 개발자가 의도적으로 변환할 수 있는데, 이것을 명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type casting) 이라고 합니다.

```javascript
var x = 10;
var str = x.toString(); // 숫자를 문자열로 변환
console.log(typeof str); // string
```

자바스크립트는 동적 타입 언어로 개발자의 의도와 상관없이 자바스크립트 엔지에 의해 암묵적으로 타입이 변환되기도 합니다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion) 이라고 합니다.

```javascript
var x = 10;
var str = x + ""; // 숫자 타입을 문자열과 합치면 문자열로 변환된다.
console.log(typeof str); // string
console.log(x); // 10
```

### 객체

자바스크립트는 객체 기반의 스크립트 언어이며 자바스크립트를 이루도 있는 거의 모든 것이 객체입니다. 자바스크립트 객체는 키(key) 와 값(value)으로 구성된 프로퍼티(Property)의 집합입니다.

#### 프로퍼티

프로퍼티는 키와 값으로 구성되고 프로퍼티 키로 유일하게 식별할 수 있습니다. 즉 키는 프로퍼티를 식별하기 위한 식별자 입니다. 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 할당됩니다.

```javascript
var person = {
  name: "Lee",
  gender: "male",
  sayHello: function () {
    console.log("Hello Im" + this.name);
  },
};
```

#

### 객체 접근

객체의 프로퍼티 값에 접근하는 방법은 마침표 표기법과 대괄호 표기법이 있습니다.

```javascript
console.log(person.name); // Lee
console.log(person["name"]); // Lee
```

대괄호 표기법을 사용하는 경우, 대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열이어야 합니다.
객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환합니다.

#### for-in 문

for-in 문을 이용해서 객체에 포함된 프로퍼티에 대한 루프를 수행할 수 있습니다.

```javascript
var person = {
  "first-name": "WJ",
  "last-name": "Kim",
  gender: "male",
};

for (var key in person) {
  console.log(key + ": " + person[key]);
}

/*
first-name: WJ
lasat-name: Kim
gender: male 
*/
```

#

### Pass-by-reference

object type을 객체 타입 또는 참조 타입이라 합니다. 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리됨을 의미합니다. 원시 타입은 값이 한번 정해지면 변경할 수 없지만, 객체는 프로퍼티를 추가, 변경, 삭제가 가능합니다.  
객체 타입은 동적으로 변화할 수 있으므로 어느 정도의 메모리 공간을 확보해야 하는지 예측할 수 없기 때문에 런타임에 메모리 공간을 확보하고 메모리의 힙 영역에 저장됩니다.

```javascript
var foo = {
  val: 10,
};

var bar = foo;
console.log(foo.val, bar.val); // 10 10
console.log(foo === bar); // true

bar.val = 20;
console.log(foo.val, bar.val); // 20 20
console.log(foo === bar); // true
```

foo는 객체 자체를 저장하고 있지 않고 객체의 참조값(address)를 저장합니다.  
bar에 foo를 할당하면 foo가 가르키는 참조값을 bar도 똑같이 저장됩니다. 즉, 두 변수 모두 동일한 객체를 참조하고 있습니다. 따라서 val값을 변경하면 두 변수 모두 변경된 값을 참조하게 됩니다.

### 함수

함수란 어떤 작업을 수행하기 위해 필요한 문(statement) 들의 집합을 정의한 코드 블록입니다. 함수는 이름과 매개변수를 가지며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행합니다. 함수는 호출에 의해 실행되고 여러번 호출할 수 있습니다.

#### 함수 정의

> 함수 선언문

```javascript
function square(number) {
  return number * number;
}
```

> 함수 표현식

```javascript
var square = function (number) {
  return number * number;
};

var foo = square;
```

함수 표현식은 함수명을 생략할 수 있습니다. 이런 함수를 익명 함수(anonymous function)이라고 합니다. 함수 표현식에서는 함수명을 생략하는 것이 일반적입니다.  
함수는 일급객체이기 때문에 변수에 할당할 수 있는데 이 변수는 함수명이 아니라 할당된 함수를 가리키는 참조값을 저장합니다. 함수를 호출할 때 함수를 가리키는 변수명을 사용합니다.

#### 함수 호이스팅

```javascript
var res = square(5); // 25

function square(number) {
  return number * number;
}
```

함수 선언문으로 함수가 정의되기 이전에 함수 호출이 가능합니다. 함수 선언문의 경우 함수 선언의 위치와 상관없이 코드 내 어느 곳에서든지 함수 호출이 가능한다, 이를 함수 호이스팅이라고 합니다.  
함수 선언문으로 정의된 함수는 함수 선언, 초기화, 할당이 한번에 이루어집니다. 따라서 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능합니다.

```javascript
var res = square(5); // TypeError: square is not a function

function square(number) {
  return number * number;
}
```

함수 표현식의 경우에는 함수 선언문과 달리 TypeError가 발생합니다. 함수 표현식의 경우 함수 호이스팅이 하닌 변수 호이스팅이 발생합니다. 변수 호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행되기 때문에 에러가 발생합니다.

#

### 프로토타입

자바스크립트는 프로토타입 기반 객체지향 프로그래밍 언어입니다. 클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체를 생성합니다. 반면 프로토타입 기반 객체지향 프로그래밍 언어는 클래스 없이 객체를 생성할 수 있습니다.  
자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있습니다. 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있는데, 이러한 부모 객체를 프로토타입 객체 또는 프로토타입이라고 합니다.  
프로토타입을 쉽게 이해하기 위해서는 부모의 유전자라고 생각하면 이해하기 쉽습니다. 객체에서 어떤 프로퍼티를 찾을 때 자식 객체에 존재하지 않는다면 부모 객체의 유전자 즉, 프로토타입까지 확인을 합니다. 그리고 이것을 프로토타입 체인이라고 합니다.

```javascript
function person(name, age) {
  this.name = name;
  this.age = age;
}

var kim = new person("kim", 30);
console.log(kim); // {name: 'kim', age: 30}
console.log(kim.gender); // undefined

person.prototype.gender = "male";
console.log(kim); // {name: 'kim', age: 30}
console.log(kim.gender); // 'male'
```

#

### 스코프

스코프는 범위를 나타내는 말로 자바스크립트의 스코프는 변수에 접근할 수 있는 범위를 말합니다.

```javascript
var a = 10; // 전역 스코프

function foo() {
  //지역(함수) 스코프
  var a = 100;
  console.log(a);
}

foo(); // 100
console.log(a); // 10
```

#

### 클로저

클로저는 MDN에서 다음과 같이 정의하고 있습니다.

> 클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경과의 조합이다.

이해하기 어렵게 설명이 되어 있는데, 쉽게 설명한다면  
함수 내에서 함수를 리턴할때, 외부함수의 실행이 끝났어도 내부함수가 외부함수의 환경 즉, 변수를 기억하고 있다는 것입니다.

```javascript
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log(count);
  };
}

var start = outer();
start(); // 1
start(); // 2
start(); // 3
```

#### 클로저 함수의 장점

- 데이터를 보존할 수 있다.
  - 외부함수의 실행이 끝나더라도 외부함수의 변수를 사용할 수 있습니다.
- 정보의 접근을 제한할 수 있다.
- 모듈화에 유리하다.
  - 클로저를 통해 데이터와 메소드를 묶어다닐 수 있기 때문에 모듈화에 유리합니다.
